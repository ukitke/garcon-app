import { Request, Response, NextFunction } from 'express';\nimport rateLimit from 'express-rate-limit';\nimport helmet from 'helmet';\nimport { body, validationResult, param, query } from 'express-validator';\nimport xss from 'xss';\nimport DOMPurify from 'isomorphic-dompurify';\nimport { auditLogger } from '../services/auditLogger';\nimport { securityConfig } from '../config/security';\n\n// Rate limiting configurations\nexport const createRateLimiter = (windowMs: number, max: number, message?: string) => {\n  return rateLimit({\n    windowMs,\n    max,\n    message: message || 'Too many requests from this IP, please try again later.',\n    standardHeaders: true,\n    legacyHeaders: false,\n    handler: (req: Request, res: Response) => {\n      auditLogger.logSecurityEvent({\n        type: 'RATE_LIMIT_EXCEEDED',\n        ip: req.ip,\n        userAgent: req.get('User-Agent'),\n        endpoint: req.path,\n        method: req.method,\n        timestamp: new Date(),\n      });\n      \n      res.status(429).json({\n        success: false,\n        error: 'Rate limit exceeded',\n        retryAfter: Math.ceil(windowMs / 1000),\n      });\n    },\n  });\n};\n\n// Different rate limits for different endpoints\nexport const authRateLimit = createRateLimiter(\n  15 * 60 * 1000, // 15 minutes\n  5, // 5 attempts\n  'Too many authentication attempts, please try again later.'\n);\n\nexport const apiRateLimit = createRateLimiter(\n  15 * 60 * 1000, // 15 minutes\n  100 // 100 requests\n);\n\nexport const strictRateLimit = createRateLimiter(\n  60 * 1000, // 1 minute\n  10 // 10 requests\n);\n\nexport const paymentRateLimit = createRateLimiter(\n  60 * 60 * 1000, // 1 hour\n  20, // 20 payment attempts\n  'Too many payment attempts, please try again later.'\n);\n\n// Helmet security headers configuration\nexport const helmetConfig = helmet({\n  contentSecurityPolicy: {\n    directives: {\n      defaultSrc: [\"'self'\"],\n      styleSrc: [\"'self'\", \"'unsafe-inline'\", 'https://fonts.googleapis.com'],\n      fontSrc: [\"'self'\", 'https://fonts.gstatic.com'],\n      imgSrc: [\"'self'\", 'data:', 'https:'],\n      scriptSrc: [\"'self'\"],\n      connectSrc: [\"'self'\", 'wss:', 'https:'],\n      frameSrc: [\"'none'\"],\n      objectSrc: [\"'none'\"],\n      upgradeInsecureRequests: [],\n    },\n  },\n  crossOriginEmbedderPolicy: false,\n  hsts: {\n    maxAge: 31536000, // 1 year\n    includeSubDomains: true,\n    preload: true,\n  },\n});\n\n// Input validation schemas\nexport const validationSchemas = {\n  // User registration validation\n  userRegistration: [\n    body('email')\n      .isEmail()\n      .normalizeEmail()\n      .isLength({ max: 255 })\n      .withMessage('Valid email is required'),\n    body('password')\n      .isLength({ min: 8, max: 128 })\n      .matches(/^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]/)\n      .withMessage('Password must contain at least 8 characters with uppercase, lowercase, number and special character'),\n    body('name')\n      .trim()\n      .isLength({ min: 1, max: 100 })\n      .matches(/^[a-zA-Z\\s'-]+$/)\n      .withMessage('Name must contain only letters, spaces, hyphens and apostrophes'),\n    body('phone')\n      .optional()\n      .isMobilePhone('any')\n      .withMessage('Valid phone number is required'),\n  ],\n\n  // User login validation\n  userLogin: [\n    body('email')\n      .isEmail()\n      .normalizeEmail()\n      .withMessage('Valid email is required'),\n    body('password')\n      .isLength({ min: 1 })\n      .withMessage('Password is required'),\n  ],\n\n  // Location validation\n  locationCoordinates: [\n    query('latitude')\n      .isFloat({ min: -90, max: 90 })\n      .withMessage('Valid latitude is required'),\n    query('longitude')\n      .isFloat({ min: -180, max: 180 })\n      .withMessage('Valid longitude is required'),\n    query('radius')\n      .optional()\n      .isInt({ min: 100, max: 50000 })\n      .withMessage('Radius must be between 100 and 50000 meters'),\n  ],\n\n  // Order validation\n  orderCreation: [\n    body('sessionId')\n      .isUUID()\n      .withMessage('Valid session ID is required'),\n    body('items')\n      .isArray({ min: 1, max: 50 })\n      .withMessage('Order must contain 1-50 items'),\n    body('items.*.menuItemId')\n      .isUUID()\n      .withMessage('Valid menu item ID is required'),\n    body('items.*.quantity')\n      .isInt({ min: 1, max: 20 })\n      .withMessage('Quantity must be between 1 and 20'),\n    body('items.*.specialInstructions')\n      .optional()\n      .isLength({ max: 500 })\n      .withMessage('Special instructions must be less than 500 characters'),\n  ],\n\n  // Payment validation\n  paymentProcessing: [\n    body('orderId')\n      .isUUID()\n      .withMessage('Valid order ID is required'),\n    body('amount')\n      .isFloat({ min: 0.01, max: 10000 })\n      .withMessage('Amount must be between 0.01 and 10000'),\n    body('method')\n      .isIn(['stripe', 'paypal', 'apple_pay', 'google_pay', 'satispay'])\n      .withMessage('Valid payment method is required'),\n    body('paymentMethodId')\n      .isLength({ min: 1, max: 255 })\n      .withMessage('Payment method ID is required'),\n  ],\n\n  // UUID parameter validation\n  uuidParam: (paramName: string) => [\n    param(paramName)\n      .isUUID()\n      .withMessage(`Valid ${paramName} is required`),\n  ],\n\n  // Pagination validation\n  pagination: [\n    query('page')\n      .optional()\n      .isInt({ min: 1, max: 1000 })\n      .withMessage('Page must be between 1 and 1000'),\n    query('limit')\n      .optional()\n      .isInt({ min: 1, max: 100 })\n      .withMessage('Limit must be between 1 and 100'),\n  ],\n};\n\n// Validation error handler\nexport const handleValidationErrors = (req: Request, res: Response, next: NextFunction) => {\n  const errors = validationResult(req);\n  \n  if (!errors.isEmpty()) {\n    auditLogger.logSecurityEvent({\n      type: 'VALIDATION_ERROR',\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      endpoint: req.path,\n      method: req.method,\n      errors: errors.array(),\n      timestamp: new Date(),\n    });\n\n    return res.status(400).json({\n      success: false,\n      error: 'Validation failed',\n      details: errors.array().map(error => ({\n        field: error.param,\n        message: error.msg,\n        value: error.value,\n      })),\n    });\n  }\n  \n  next();\n};\n\n// XSS protection middleware\nexport const xssProtection = (req: Request, res: Response, next: NextFunction) => {\n  // Sanitize request body\n  if (req.body && typeof req.body === 'object') {\n    req.body = sanitizeObject(req.body);\n  }\n  \n  // Sanitize query parameters\n  if (req.query && typeof req.query === 'object') {\n    req.query = sanitizeObject(req.query);\n  }\n  \n  next();\n};\n\n// Recursive object sanitization\nconst sanitizeObject = (obj: any): any => {\n  if (typeof obj === 'string') {\n    return DOMPurify.sanitize(xss(obj));\n  }\n  \n  if (Array.isArray(obj)) {\n    return obj.map(sanitizeObject);\n  }\n  \n  if (obj && typeof obj === 'object') {\n    const sanitized: any = {};\n    for (const [key, value] of Object.entries(obj)) {\n      sanitized[key] = sanitizeObject(value);\n    }\n    return sanitized;\n  }\n  \n  return obj;\n};\n\n// SQL injection prevention middleware\nexport const sqlInjectionProtection = (req: Request, res: Response, next: NextFunction) => {\n  const suspiciousPatterns = [\n    /('|(\\-\\-)|(;)|(\\||\\|)|(\\*|\\*))/i,\n    /(union|select|insert|delete|update|drop|create|alter|exec|execute)/i,\n    /(script|javascript|vbscript|onload|onerror|onclick)/i,\n  ];\n  \n  const checkForSqlInjection = (value: any): boolean => {\n    if (typeof value === 'string') {\n      return suspiciousPatterns.some(pattern => pattern.test(value));\n    }\n    \n    if (Array.isArray(value)) {\n      return value.some(checkForSqlInjection);\n    }\n    \n    if (value && typeof value === 'object') {\n      return Object.values(value).some(checkForSqlInjection);\n    }\n    \n    return false;\n  };\n  \n  const hasSqlInjection = [\n    ...Object.values(req.query || {}),\n    ...Object.values(req.body || {}),\n    ...Object.values(req.params || {}),\n  ].some(checkForSqlInjection);\n  \n  if (hasSqlInjection) {\n    auditLogger.logSecurityEvent({\n      type: 'SQL_INJECTION_ATTEMPT',\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      endpoint: req.path,\n      method: req.method,\n      suspiciousData: {\n        query: req.query,\n        body: req.body,\n        params: req.params,\n      },\n      timestamp: new Date(),\n    });\n    \n    return res.status(400).json({\n      success: false,\n      error: 'Invalid request data',\n    });\n  }\n  \n  next();\n};\n\n// Request size limiting\nexport const requestSizeLimit = (maxSize: number) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    const contentLength = parseInt(req.get('content-length') || '0', 10);\n    \n    if (contentLength > maxSize) {\n      auditLogger.logSecurityEvent({\n        type: 'REQUEST_SIZE_EXCEEDED',\n        ip: req.ip,\n        userAgent: req.get('User-Agent'),\n        endpoint: req.path,\n        method: req.method,\n        contentLength,\n        maxSize,\n        timestamp: new Date(),\n      });\n      \n      return res.status(413).json({\n        success: false,\n        error: 'Request entity too large',\n      });\n    }\n    \n    next();\n  };\n};\n\n// IP whitelist/blacklist middleware\nexport const ipFilter = (req: Request, res: Response, next: NextFunction) => {\n  const clientIp = req.ip;\n  \n  // Check blacklist\n  if (securityConfig.blacklistedIPs.includes(clientIp)) {\n    auditLogger.logSecurityEvent({\n      type: 'BLACKLISTED_IP_ACCESS',\n      ip: clientIp,\n      userAgent: req.get('User-Agent'),\n      endpoint: req.path,\n      method: req.method,\n      timestamp: new Date(),\n    });\n    \n    return res.status(403).json({\n      success: false,\n      error: 'Access denied',\n    });\n  }\n  \n  // Check whitelist (if configured)\n  if (securityConfig.whitelistedIPs.length > 0 && !securityConfig.whitelistedIPs.includes(clientIp)) {\n    auditLogger.logSecurityEvent({\n      type: 'NON_WHITELISTED_IP_ACCESS',\n      ip: clientIp,\n      userAgent: req.get('User-Agent'),\n      endpoint: req.path,\n      method: req.method,\n      timestamp: new Date(),\n    });\n    \n    return res.status(403).json({\n      success: false,\n      error: 'Access denied',\n    });\n  }\n  \n  next();\n};\n\n// Suspicious activity detection\nexport const suspiciousActivityDetection = (req: Request, res: Response, next: NextFunction) => {\n  const suspiciousIndicators = [\n    // Check for common attack patterns in User-Agent\n    /sqlmap|nikto|nmap|masscan|nessus|openvas|w3af|skipfish|burp|owasp/i.test(req.get('User-Agent') || ''),\n    \n    // Check for suspicious headers\n    req.get('X-Forwarded-For')?.split(',').length > 5,\n    \n    // Check for unusual request patterns\n    req.path.includes('../') || req.path.includes('..\\\\'),\n    \n    // Check for common vulnerability scanning patterns\n    /\\.(php|asp|jsp|cgi)$/i.test(req.path),\n    \n    // Check for admin panel access attempts\n    /\\/(admin|administrator|wp-admin|phpmyadmin)/i.test(req.path),\n  ];\n  \n  const suspiciousScore = suspiciousIndicators.filter(Boolean).length;\n  \n  if (suspiciousScore >= 2) {\n    auditLogger.logSecurityEvent({\n      type: 'SUSPICIOUS_ACTIVITY_DETECTED',\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      endpoint: req.path,\n      method: req.method,\n      suspiciousScore,\n      indicators: suspiciousIndicators.map((indicator, index) => ({\n        index,\n        triggered: indicator,\n      })).filter(item => item.triggered),\n      timestamp: new Date(),\n    });\n    \n    // Increase rate limiting for suspicious IPs\n    // This would typically integrate with a more sophisticated threat detection system\n  }\n  \n  next();\n};\n\n// CORS configuration\nexport const corsConfig = {\n  origin: (origin: string | undefined, callback: (err: Error | null, allow?: boolean) => void) => {\n    // Allow requests with no origin (mobile apps, Postman, etc.)\n    if (!origin) return callback(null, true);\n    \n    if (securityConfig.allowedOrigins.includes(origin)) {\n      return callback(null, true);\n    }\n    \n    auditLogger.logSecurityEvent({\n      type: 'CORS_VIOLATION',\n      origin,\n      timestamp: new Date(),\n    });\n    \n    return callback(new Error('Not allowed by CORS'), false);\n  },\n  credentials: true,\n  optionsSuccessStatus: 200,\n  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],\n  allowedHeaders: [\n    'Origin',\n    'X-Requested-With',\n    'Content-Type',\n    'Accept',\n    'Authorization',\n    'X-API-Key',\n  ],\n};\n\n// Security headers middleware\nexport const securityHeaders = (req: Request, res: Response, next: NextFunction) => {\n  // Remove server information\n  res.removeHeader('X-Powered-By');\n  \n  // Add security headers\n  res.setHeader('X-Content-Type-Options', 'nosniff');\n  res.setHeader('X-Frame-Options', 'DENY');\n  res.setHeader('X-XSS-Protection', '1; mode=block');\n  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');\n  res.setHeader('Permissions-Policy', 'geolocation=(), microphone=(), camera=()');\n  \n  next();\n};\n\n// Request logging middleware\nexport const requestLogger = (req: Request, res: Response, next: NextFunction) => {\n  const startTime = Date.now();\n  \n  res.on('finish', () => {\n    const duration = Date.now() - startTime;\n    \n    auditLogger.logRequest({\n      method: req.method,\n      url: req.url,\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      statusCode: res.statusCode,\n      duration,\n      contentLength: res.get('content-length'),\n      timestamp: new Date(),\n    });\n  });\n  \n  next();\n};\n\n// Error handling middleware\nexport const securityErrorHandler = (err: any, req: Request, res: Response, next: NextFunction) => {\n  // Log security-related errors\n  if (err.type === 'security' || err.status === 403 || err.status === 401) {\n    auditLogger.logSecurityEvent({\n      type: 'SECURITY_ERROR',\n      ip: req.ip,\n      userAgent: req.get('User-Agent'),\n      endpoint: req.path,\n      method: req.method,\n      error: {\n        message: err.message,\n        stack: err.stack,\n        type: err.type,\n        status: err.status,\n      },\n      timestamp: new Date(),\n    });\n  }\n  \n  // Don't expose internal error details in production\n  if (process.env.NODE_ENV === 'production') {\n    return res.status(err.status || 500).json({\n      success: false,\n      error: err.status === 404 ? 'Not found' : 'Internal server error',\n    });\n  }\n  \n  next(err);\n};\n\nexport default {\n  createRateLimiter,\n  authRateLimit,\n  apiRateLimit,\n  strictRateLimit,\n  paymentRateLimit,\n  helmetConfig,\n  validationSchemas,\n  handleValidationErrors,\n  xssProtection,\n  sqlInjectionProtection,\n  requestSizeLimit,\n  ipFilter,\n  suspiciousActivityDetection,\n  corsConfig,\n  securityHeaders,\n  requestLogger,\n  securityErrorHandler,\n};"