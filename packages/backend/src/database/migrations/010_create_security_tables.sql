-- Security Events Table\nCREATE TABLE IF NOT EXISTS security_events (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    type VARCHAR(100) NOT NULL,\n    severity VARCHAR(20) NOT NULL CHECK (severity IN ('low', 'medium', 'high', 'critical')),\n    ip INET,\n    user_agent TEXT,\n    endpoint VARCHAR(500),\n    method VARCHAR(10),\n    user_id UUID REFERENCES users(id) ON DELETE SET NULL,\n    session_id VARCHAR(255),\n    data JSONB,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Request Logs Table\nCREATE TABLE IF NOT EXISTS request_logs (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    method VARCHAR(10) NOT NULL,\n    url TEXT NOT NULL,\n    ip INET,\n    user_agent TEXT,\n    status_code INTEGER NOT NULL,\n    duration INTEGER NOT NULL, -- in milliseconds\n    content_length INTEGER,\n    user_id UUID REFERENCES users(id) ON DELETE SET NULL,\n    session_id VARCHAR(255),\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Audit Events Table\nCREATE TABLE IF NOT EXISTS audit_events (\n    id UUID PRIMARY KEY,\n    type VARCHAR(50) NOT NULL CHECK (type IN ('security', 'request', 'business', 'system')),\n    category VARCHAR(100) NOT NULL,\n    action VARCHAR(200) NOT NULL,\n    user_id UUID REFERENCES users(id) ON DELETE SET NULL,\n    session_id VARCHAR(255),\n    resource_id VARCHAR(255),\n    resource_type VARCHAR(100),\n    ip INET,\n    user_agent TEXT,\n    data JSONB,\n    result VARCHAR(20) NOT NULL CHECK (result IN ('success', 'failure', 'error')),\n    hash VARCHAR(64), -- SHA-256 hash for integrity verification\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Security Alerts Table\nCREATE TABLE IF NOT EXISTS security_alerts (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    type VARCHAR(100) NOT NULL,\n    ip INET,\n    count INTEGER NOT NULL,\n    threshold_count INTEGER NOT NULL,\n    time_window INTEGER NOT NULL, -- in seconds\n    severity VARCHAR(20) NOT NULL CHECK (severity IN ('low', 'medium', 'high', 'critical')),\n    data JSONB,\n    acknowledged BOOLEAN DEFAULT FALSE,\n    acknowledged_by UUID REFERENCES users(id) ON DELETE SET NULL,\n    acknowledged_at TIMESTAMP WITH TIME ZONE,\n    resolved BOOLEAN DEFAULT FALSE,\n    resolved_by UUID REFERENCES users(id) ON DELETE SET NULL,\n    resolved_at TIMESTAMP WITH TIME ZONE,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Blocked IPs Table\nCREATE TABLE IF NOT EXISTS blocked_ips (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    ip INET NOT NULL UNIQUE,\n    reason TEXT NOT NULL,\n    blocked_by UUID REFERENCES users(id) ON DELETE SET NULL,\n    blocked_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    expires_at TIMESTAMP WITH TIME ZONE,\n    auto_blocked BOOLEAN DEFAULT FALSE,\n    is_active BOOLEAN DEFAULT TRUE,\n    unblocked_by UUID REFERENCES users(id) ON DELETE SET NULL,\n    unblocked_at TIMESTAMP WITH TIME ZONE\n);\n\n-- Failed Login Attempts Table\nCREATE TABLE IF NOT EXISTS failed_login_attempts (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    email VARCHAR(255) NOT NULL,\n    ip INET NOT NULL,\n    user_agent TEXT,\n    attempt_count INTEGER DEFAULT 1,\n    last_attempt_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    locked_until TIMESTAMP WITH TIME ZONE,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- User Sessions Table (for session management)\nCREATE TABLE IF NOT EXISTS user_sessions (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    session_id VARCHAR(255) NOT NULL UNIQUE,\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    ip INET,\n    user_agent TEXT,\n    device_fingerprint VARCHAR(255),\n    location_country VARCHAR(2),\n    location_city VARCHAR(100),\n    is_active BOOLEAN DEFAULT TRUE,\n    last_activity TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    expires_at TIMESTAMP WITH TIME ZONE NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- API Keys Table (for future API key authentication)\nCREATE TABLE IF NOT EXISTS api_keys (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    key_hash VARCHAR(255) NOT NULL UNIQUE,\n    name VARCHAR(100) NOT NULL,\n    user_id UUID REFERENCES users(id) ON DELETE CASCADE,\n    location_id UUID REFERENCES locations(id) ON DELETE CASCADE,\n    permissions JSONB DEFAULT '[]'::jsonb,\n    rate_limit INTEGER DEFAULT 1000, -- requests per hour\n    is_active BOOLEAN DEFAULT TRUE,\n    last_used_at TIMESTAMP WITH TIME ZONE,\n    expires_at TIMESTAMP WITH TIME ZONE,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Security Settings Table (per location/user)\nCREATE TABLE IF NOT EXISTS security_settings (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    entity_type VARCHAR(20) NOT NULL CHECK (entity_type IN ('user', 'location')),\n    entity_id UUID NOT NULL,\n    setting_key VARCHAR(100) NOT NULL,\n    setting_value JSONB NOT NULL,\n    updated_by UUID REFERENCES users(id) ON DELETE SET NULL,\n    updated_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP,\n    UNIQUE(entity_type, entity_id, setting_key)\n);\n\n-- Password History Table (to prevent password reuse)\nCREATE TABLE IF NOT EXISTS password_history (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    password_hash VARCHAR(255) NOT NULL,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Two-Factor Authentication Table (for future 2FA implementation)\nCREATE TABLE IF NOT EXISTS two_factor_auth (\n    id UUID PRIMARY KEY DEFAULT gen_random_uuid(),\n    user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,\n    method VARCHAR(20) NOT NULL CHECK (method IN ('totp', 'sms', 'email')),\n    secret VARCHAR(255), -- For TOTP\n    phone VARCHAR(20), -- For SMS\n    email VARCHAR(255), -- For email\n    backup_codes JSONB, -- Array of backup codes\n    is_enabled BOOLEAN DEFAULT FALSE,\n    verified_at TIMESTAMP WITH TIME ZONE,\n    created_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP\n);\n\n-- Indexes for performance\nCREATE INDEX IF NOT EXISTS idx_security_events_type_created_at ON security_events(type, created_at DESC);\nCREATE INDEX IF NOT EXISTS idx_security_events_ip_created_at ON security_events(ip, created_at DESC);\nCREATE INDEX IF NOT EXISTS idx_security_events_user_id ON security_events(user_id);\nCREATE INDEX IF NOT EXISTS idx_security_events_severity ON security_events(severity);\n\nCREATE INDEX IF NOT EXISTS idx_request_logs_created_at ON request_logs(created_at DESC);\nCREATE INDEX IF NOT EXISTS idx_request_logs_ip ON request_logs(ip);\nCREATE INDEX IF NOT EXISTS idx_request_logs_user_id ON request_logs(user_id);\nCREATE INDEX IF NOT EXISTS idx_request_logs_status_code ON request_logs(status_code);\n\nCREATE INDEX IF NOT EXISTS idx_audit_events_type_created_at ON audit_events(type, created_at DESC);\nCREATE INDEX IF NOT EXISTS idx_audit_events_user_id ON audit_events(user_id);\nCREATE INDEX IF NOT EXISTS idx_audit_events_resource ON audit_events(resource_type, resource_id);\nCREATE INDEX IF NOT EXISTS idx_audit_events_action ON audit_events(action);\n\nCREATE INDEX IF NOT EXISTS idx_security_alerts_type_created_at ON security_alerts(type, created_at DESC);\nCREATE INDEX IF NOT EXISTS idx_security_alerts_severity ON security_alerts(severity);\nCREATE INDEX IF NOT EXISTS idx_security_alerts_acknowledged ON security_alerts(acknowledged);\nCREATE INDEX IF NOT EXISTS idx_security_alerts_resolved ON security_alerts(resolved);\n\nCREATE INDEX IF NOT EXISTS idx_blocked_ips_ip ON blocked_ips(ip);\nCREATE INDEX IF NOT EXISTS idx_blocked_ips_is_active ON blocked_ips(is_active);\nCREATE INDEX IF NOT EXISTS idx_blocked_ips_expires_at ON blocked_ips(expires_at);\n\nCREATE INDEX IF NOT EXISTS idx_failed_login_attempts_email ON failed_login_attempts(email);\nCREATE INDEX IF NOT EXISTS idx_failed_login_attempts_ip ON failed_login_attempts(ip);\nCREATE INDEX IF NOT EXISTS idx_failed_login_attempts_locked_until ON failed_login_attempts(locked_until);\n\nCREATE INDEX IF NOT EXISTS idx_user_sessions_user_id ON user_sessions(user_id);\nCREATE INDEX IF NOT EXISTS idx_user_sessions_session_id ON user_sessions(session_id);\nCREATE INDEX IF NOT EXISTS idx_user_sessions_is_active ON user_sessions(is_active);\nCREATE INDEX IF NOT EXISTS idx_user_sessions_expires_at ON user_sessions(expires_at);\n\nCREATE INDEX IF NOT EXISTS idx_api_keys_key_hash ON api_keys(key_hash);\nCREATE INDEX IF NOT EXISTS idx_api_keys_user_id ON api_keys(user_id);\nCREATE INDEX IF NOT EXISTS idx_api_keys_location_id ON api_keys(location_id);\nCREATE INDEX IF NOT EXISTS idx_api_keys_is_active ON api_keys(is_active);\n\nCREATE INDEX IF NOT EXISTS idx_security_settings_entity ON security_settings(entity_type, entity_id);\nCREATE INDEX IF NOT EXISTS idx_security_settings_key ON security_settings(setting_key);\n\nCREATE INDEX IF NOT EXISTS idx_password_history_user_id ON password_history(user_id);\nCREATE INDEX IF NOT EXISTS idx_password_history_created_at ON password_history(created_at DESC);\n\nCREATE INDEX IF NOT EXISTS idx_two_factor_auth_user_id ON two_factor_auth(user_id);\nCREATE INDEX IF NOT EXISTS idx_two_factor_auth_method ON two_factor_auth(method);\nCREATE INDEX IF NOT EXISTS idx_two_factor_auth_is_enabled ON two_factor_auth(is_enabled);\n\n-- Triggers for automatic cleanup\n\n-- Function to clean up old request logs\nCREATE OR REPLACE FUNCTION cleanup_old_request_logs()\nRETURNS void AS $$\nBEGIN\n    DELETE FROM request_logs \n    WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '30 days';\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Function to clean up expired blocked IPs\nCREATE OR REPLACE FUNCTION cleanup_expired_blocked_ips()\nRETURNS void AS $$\nBEGIN\n    UPDATE blocked_ips \n    SET is_active = FALSE \n    WHERE expires_at IS NOT NULL \n    AND expires_at < CURRENT_TIMESTAMP \n    AND is_active = TRUE;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Function to clean up expired sessions\nCREATE OR REPLACE FUNCTION cleanup_expired_sessions()\nRETURNS void AS $$\nBEGIN\n    UPDATE user_sessions \n    SET is_active = FALSE \n    WHERE expires_at < CURRENT_TIMESTAMP \n    AND is_active = TRUE;\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Function to clean up old failed login attempts\nCREATE OR REPLACE FUNCTION cleanup_old_failed_login_attempts()\nRETURNS void AS $$\nBEGIN\n    DELETE FROM failed_login_attempts \n    WHERE created_at < CURRENT_TIMESTAMP - INTERVAL '7 days'\n    AND (locked_until IS NULL OR locked_until < CURRENT_TIMESTAMP);\nEND;\n$$ LANGUAGE plpgsql;\n\n-- Add constraints to existing users table if not exists\nDO $$\nBEGIN\n    -- Add password_changed_at column if it doesn't exist\n    IF NOT EXISTS (SELECT 1 FROM information_schema.columns \n                   WHERE table_name = 'users' AND column_name = 'password_changed_at') THEN\n        ALTER TABLE users ADD COLUMN password_changed_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP;\n    END IF;\n    \n    -- Add failed_login_attempts column if it doesn't exist\n    IF NOT EXISTS (SELECT 1 FROM information_schema.columns \n                   WHERE table_name = 'users' AND column_name = 'failed_login_attempts') THEN\n        ALTER TABLE users ADD COLUMN failed_login_attempts INTEGER DEFAULT 0;\n    END IF;\n    \n    -- Add locked_until column if it doesn't exist\n    IF NOT EXISTS (SELECT 1 FROM information_schema.columns \n                   WHERE table_name = 'users' AND column_name = 'locked_until') THEN\n        ALTER TABLE users ADD COLUMN locked_until TIMESTAMP WITH TIME ZONE;\n    END IF;\n    \n    -- Add last_login_at column if it doesn't exist\n    IF NOT EXISTS (SELECT 1 FROM information_schema.columns \n                   WHERE table_name = 'users' AND column_name = 'last_login_at') THEN\n        ALTER TABLE users ADD COLUMN last_login_at TIMESTAMP WITH TIME ZONE;\n    END IF;\n    \n    -- Add last_login_ip column if it doesn't exist\n    IF NOT EXISTS (SELECT 1 FROM information_schema.columns \n                   WHERE table_name = 'users' AND column_name = 'last_login_ip') THEN\n        ALTER TABLE users ADD COLUMN last_login_ip INET;\n    END IF;\nEND\n$$;\n\n-- Create a view for security dashboard\nCREATE OR REPLACE VIEW security_dashboard AS\nSELECT \n    'security_events' as metric_type,\n    COUNT(*) as total_count,\n    COUNT(*) FILTER (WHERE severity = 'critical') as critical_count,\n    COUNT(*) FILTER (WHERE severity = 'high') as high_count,\n    COUNT(*) FILTER (WHERE severity = 'medium') as medium_count,\n    COUNT(*) FILTER (WHERE severity = 'low') as low_count,\n    COUNT(*) FILTER (WHERE created_at >= CURRENT_TIMESTAMP - INTERVAL '24 hours') as last_24h_count,\n    COUNT(*) FILTER (WHERE created_at >= CURRENT_TIMESTAMP - INTERVAL '7 days') as last_7d_count\nFROM security_events\nUNION ALL\nSELECT \n    'security_alerts' as metric_type,\n    COUNT(*) as total_count,\n    COUNT(*) FILTER (WHERE severity = 'critical') as critical_count,\n    COUNT(*) FILTER (WHERE severity = 'high') as high_count,\n    COUNT(*) FILTER (WHERE severity = 'medium') as medium_count,\n    COUNT(*) FILTER (WHERE severity = 'low') as low_count,\n    COUNT(*) FILTER (WHERE created_at >= CURRENT_TIMESTAMP - INTERVAL '24 hours') as last_24h_count,\n    COUNT(*) FILTER (WHERE created_at >= CURRENT_TIMESTAMP - INTERVAL '7 days') as last_7d_count\nFROM security_alerts\nUNION ALL\nSELECT \n    'blocked_ips' as metric_type,\n    COUNT(*) as total_count,\n    0 as critical_count,\n    0 as high_count,\n    0 as medium_count,\n    0 as low_count,\n    COUNT(*) FILTER (WHERE blocked_at >= CURRENT_TIMESTAMP - INTERVAL '24 hours') as last_24h_count,\n    COUNT(*) FILTER (WHERE blocked_at >= CURRENT_TIMESTAMP - INTERVAL '7 days') as last_7d_count\nFROM blocked_ips\nWHERE is_active = TRUE;\n\n-- Grant permissions\nGRANT SELECT, INSERT, UPDATE ON ALL TABLES IN SCHEMA public TO garcon_api;\nGRANT USAGE, SELECT ON ALL SEQUENCES IN SCHEMA public TO garcon_api;\nGRANT SELECT ON security_dashboard TO garcon_api;"