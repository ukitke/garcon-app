import AWS from 'aws-sdk';\nimport sharp from 'sharp';\nimport { createHash } from 'crypto';\nimport { EventEmitter } from 'events';\nimport { Readable } from 'stream';\n\ninterface CDNConfig {\n  bucketName: string;\n  cloudFrontDistributionId: string;\n  region: string;\n  accessKeyId: string;\n  secretAccessKey: string;\n  cdnDomain: string;\n}\n\ninterface ImageOptimizationOptions {\n  width?: number;\n  height?: number;\n  quality?: number;\n  format?: 'jpeg' | 'png' | 'webp' | 'avif';\n  progressive?: boolean;\n  blur?: number;\n}\n\ninterface UploadOptions {\n  contentType?: string;\n  cacheControl?: string;\n  metadata?: Record<string, string>;\n  tags?: Record<string, string>;\n  optimize?: boolean;\n  generateThumbnails?: boolean;\n}\n\ninterface CDNAsset {\n  key: string;\n  url: string;\n  cdnUrl: string;\n  size: number;\n  contentType: string;\n  etag: string;\n  lastModified: Date;\n  metadata?: Record<string, string>;\n}\n\ninterface ThumbnailConfig {\n  name: string;\n  width: number;\n  height: number;\n  quality: number;\n  format: 'jpeg' | 'png' | 'webp';\n}\n\nclass CDNService extends EventEmitter {\n  private s3: AWS.S3;\n  private cloudFront: AWS.CloudFront;\n  private config: CDNConfig;\n  private thumbnailConfigs: ThumbnailConfig[];\n  private compressionCache: Map<string, Buffer> = new Map();\n\n  constructor(config: CDNConfig) {\n    super();\n    this.config = config;\n    \n    // Configure AWS SDK\n    AWS.config.update({\n      accessKeyId: config.accessKeyId,\n      secretAccessKey: config.secretAccessKey,\n      region: config.region,\n    });\n    \n    this.s3 = new AWS.S3({\n      apiVersion: '2006-03-01',\n      params: { Bucket: config.bucketName },\n    });\n    \n    this.cloudFront = new AWS.CloudFront({\n      apiVersion: '2020-05-31',\n    });\n    \n    this.setupThumbnailConfigs();\n  }\n\n  private setupThumbnailConfigs() {\n    this.thumbnailConfigs = [\n      { name: 'thumb_small', width: 150, height: 150, quality: 80, format: 'jpeg' },\n      { name: 'thumb_medium', width: 300, height: 300, quality: 85, format: 'jpeg' },\n      { name: 'thumb_large', width: 600, height: 600, quality: 90, format: 'jpeg' },\n      { name: 'webp_small', width: 150, height: 150, quality: 80, format: 'webp' },\n      { name: 'webp_medium', width: 300, height: 300, quality: 85, format: 'webp' },\n      { name: 'webp_large', width: 600, height: 600, quality: 90, format: 'webp' },\n    ];\n  }\n\n  public async uploadFile(\n    file: Buffer | Readable,\n    key: string,\n    options: UploadOptions = {}\n  ): Promise<CDNAsset> {\n    try {\n      let fileBuffer: Buffer;\n      \n      if (file instanceof Buffer) {\n        fileBuffer = file;\n      } else {\n        // Convert stream to buffer\n        const chunks: Buffer[] = [];\n        for await (const chunk of file) {\n          chunks.push(chunk);\n        }\n        fileBuffer = Buffer.concat(chunks);\n      }\n\n      // Optimize image if requested and file is an image\n      if (options.optimize && this.isImageFile(key)) {\n        fileBuffer = await this.optimizeImage(fileBuffer, {\n          quality: 85,\n          progressive: true,\n        });\n      }\n\n      // Generate file hash for cache busting\n      const fileHash = createHash('md5').update(fileBuffer).digest('hex');\n      const hashedKey = this.addHashToKey(key, fileHash);\n\n      // Upload to S3\n      const uploadParams: AWS.S3.PutObjectRequest = {\n        Bucket: this.config.bucketName,\n        Key: hashedKey,\n        Body: fileBuffer,\n        ContentType: options.contentType || this.getContentType(key),\n        CacheControl: options.cacheControl || 'public, max-age=31536000', // 1 year\n        Metadata: options.metadata || {},\n        TagSet: options.tags ? Object.entries(options.tags).map(([Key, Value]) => ({ Key, Value })) : undefined,\n      };\n\n      const result = await this.s3.upload(uploadParams).promise();\n      \n      const asset: CDNAsset = {\n        key: hashedKey,\n        url: result.Location,\n        cdnUrl: `https://${this.config.cdnDomain}/${hashedKey}`,\n        size: fileBuffer.length,\n        contentType: uploadParams.ContentType!,\n        etag: result.ETag.replace(/\"/g, ''),\n        lastModified: new Date(),\n        metadata: options.metadata,\n      };\n\n      // Generate thumbnails if requested\n      if (options.generateThumbnails && this.isImageFile(key)) {\n        await this.generateThumbnails(fileBuffer, hashedKey);\n      }\n\n      this.emit('fileUploaded', asset);\n      return asset;\n    } catch (error) {\n      this.emit('uploadError', { key, error });\n      throw error;\n    }\n  }\n\n  public async uploadMultipleFiles(\n    files: Array<{ file: Buffer | Readable; key: string; options?: UploadOptions }>\n  ): Promise<CDNAsset[]> {\n    const uploadPromises = files.map(({ file, key, options }) => \n      this.uploadFile(file, key, options)\n    );\n    \n    try {\n      const results = await Promise.allSettled(uploadPromises);\n      const assets: CDNAsset[] = [];\n      const errors: any[] = [];\n      \n      results.forEach((result, index) => {\n        if (result.status === 'fulfilled') {\n          assets.push(result.value);\n        } else {\n          errors.push({ index, key: files[index].key, error: result.reason });\n        }\n      });\n      \n      if (errors.length > 0) {\n        this.emit('batchUploadErrors', errors);\n      }\n      \n      return assets;\n    } catch (error) {\n      this.emit('batchUploadError', error);\n      throw error;\n    }\n  }\n\n  private async optimizeImage(\n    imageBuffer: Buffer,\n    options: ImageOptimizationOptions\n  ): Promise<Buffer> {\n    try {\n      let sharpInstance = sharp(imageBuffer);\n      \n      // Resize if dimensions specified\n      if (options.width || options.height) {\n        sharpInstance = sharpInstance.resize(options.width, options.height, {\n          fit: 'inside',\n          withoutEnlargement: true,\n        });\n      }\n      \n      // Apply blur if specified\n      if (options.blur) {\n        sharpInstance = sharpInstance.blur(options.blur);\n      }\n      \n      // Set format and quality\n      switch (options.format) {\n        case 'jpeg':\n          sharpInstance = sharpInstance.jpeg({\n            quality: options.quality || 85,\n            progressive: options.progressive || true,\n            mozjpeg: true,\n          });\n          break;\n        case 'png':\n          sharpInstance = sharpInstance.png({\n            quality: options.quality || 85,\n            progressive: options.progressive || true,\n            compressionLevel: 9,\n          });\n          break;\n        case 'webp':\n          sharpInstance = sharpInstance.webp({\n            quality: options.quality || 85,\n            effort: 6,\n          });\n          break;\n        case 'avif':\n          sharpInstance = sharpInstance.avif({\n            quality: options.quality || 85,\n            effort: 9,\n          });\n          break;\n        default:\n          // Auto-detect best format\n          sharpInstance = sharpInstance.jpeg({\n            quality: options.quality || 85,\n            progressive: true,\n          });\n      }\n      \n      return await sharpInstance.toBuffer();\n    } catch (error) {\n      console.error('Image optimization failed:', error);\n      return imageBuffer; // Return original if optimization fails\n    }\n  }\n\n  private async generateThumbnails(originalBuffer: Buffer, originalKey: string): Promise<void> {\n    const thumbnailPromises = this.thumbnailConfigs.map(async (config) => {\n      try {\n        const thumbnailBuffer = await this.optimizeImage(originalBuffer, {\n          width: config.width,\n          height: config.height,\n          quality: config.quality,\n          format: config.format,\n        });\n        \n        const thumbnailKey = this.getThumbnailKey(originalKey, config.name);\n        \n        await this.s3.upload({\n          Bucket: this.config.bucketName,\n          Key: thumbnailKey,\n          Body: thumbnailBuffer,\n          ContentType: `image/${config.format}`,\n          CacheControl: 'public, max-age=31536000',\n          Metadata: {\n            'original-key': originalKey,\n            'thumbnail-type': config.name,\n          },\n        }).promise();\n        \n        return thumbnailKey;\n      } catch (error) {\n        console.error(`Failed to generate thumbnail ${config.name}:`, error);\n        return null;\n      }\n    });\n    \n    await Promise.allSettled(thumbnailPromises);\n  }\n\n  public async deleteFile(key: string): Promise<boolean> {\n    try {\n      // Delete main file\n      await this.s3.deleteObject({\n        Bucket: this.config.bucketName,\n        Key: key,\n      }).promise();\n      \n      // Delete thumbnails if they exist\n      if (this.isImageFile(key)) {\n        await this.deleteThumbnails(key);\n      }\n      \n      // Invalidate CloudFront cache\n      await this.invalidateCache([key]);\n      \n      this.emit('fileDeleted', key);\n      return true;\n    } catch (error) {\n      this.emit('deleteError', { key, error });\n      return false;\n    }\n  }\n\n  private async deleteThumbnails(originalKey: string): Promise<void> {\n    const thumbnailKeys = this.thumbnailConfigs.map(config => \n      this.getThumbnailKey(originalKey, config.name)\n    );\n    \n    const deletePromises = thumbnailKeys.map(key => \n      this.s3.deleteObject({\n        Bucket: this.config.bucketName,\n        Key: key,\n      }).promise().catch(error => {\n        console.error(`Failed to delete thumbnail ${key}:`, error);\n      })\n    );\n    \n    await Promise.allSettled(deletePromises);\n  }\n\n  public async getFileInfo(key: string): Promise<CDNAsset | null> {\n    try {\n      const result = await this.s3.headObject({\n        Bucket: this.config.bucketName,\n        Key: key,\n      }).promise();\n      \n      return {\n        key,\n        url: `https://${this.config.bucketName}.s3.${this.config.region}.amazonaws.com/${key}`,\n        cdnUrl: `https://${this.config.cdnDomain}/${key}`,\n        size: result.ContentLength || 0,\n        contentType: result.ContentType || 'application/octet-stream',\n        etag: result.ETag?.replace(/\"/g, '') || '',\n        lastModified: result.LastModified || new Date(),\n        metadata: result.Metadata,\n      };\n    } catch (error) {\n      if (error.code === 'NotFound') {\n        return null;\n      }\n      throw error;\n    }\n  }\n\n  public async listFiles(prefix?: string, maxKeys: number = 1000): Promise<CDNAsset[]> {\n    try {\n      const params: AWS.S3.ListObjectsV2Request = {\n        Bucket: this.config.bucketName,\n        MaxKeys: maxKeys,\n      };\n      \n      if (prefix) {\n        params.Prefix = prefix;\n      }\n      \n      const result = await this.s3.listObjectsV2(params).promise();\n      \n      return (result.Contents || []).map(object => ({\n        key: object.Key!,\n        url: `https://${this.config.bucketName}.s3.${this.config.region}.amazonaws.com/${object.Key}`,\n        cdnUrl: `https://${this.config.cdnDomain}/${object.Key}`,\n        size: object.Size || 0,\n        contentType: 'application/octet-stream', // Would need separate call to get this\n        etag: object.ETag?.replace(/\"/g, '') || '',\n        lastModified: object.LastModified || new Date(),\n      }));\n    } catch (error) {\n      console.error('Failed to list files:', error);\n      return [];\n    }\n  }\n\n  public async invalidateCache(keys: string[]): Promise<boolean> {\n    try {\n      const paths = keys.map(key => `/${key}`);\n      \n      const params: AWS.CloudFront.CreateInvalidationRequest = {\n        DistributionId: this.config.cloudFrontDistributionId,\n        InvalidationBatch: {\n          Paths: {\n            Quantity: paths.length,\n            Items: paths,\n          },\n          CallerReference: `invalidation-${Date.now()}`,\n        },\n      };\n      \n      await this.cloudFront.createInvalidation(params).promise();\n      this.emit('cacheInvalidated', keys);\n      return true;\n    } catch (error) {\n      this.emit('invalidationError', { keys, error });\n      console.error('Failed to invalidate cache:', error);\n      return false;\n    }\n  }\n\n  public generateSignedUrl(key: string, expiresIn: number = 3600): string {\n    return this.s3.getSignedUrl('getObject', {\n      Bucket: this.config.bucketName,\n      Key: key,\n      Expires: expiresIn,\n    });\n  }\n\n  public generateUploadUrl(key: string, contentType: string, expiresIn: number = 3600): string {\n    return this.s3.getSignedUrl('putObject', {\n      Bucket: this.config.bucketName,\n      Key: key,\n      ContentType: contentType,\n      Expires: expiresIn,\n    });\n  }\n\n  public getThumbnailUrl(originalKey: string, thumbnailType: string): string {\n    const thumbnailKey = this.getThumbnailKey(originalKey, thumbnailType);\n    return `https://${this.config.cdnDomain}/${thumbnailKey}`;\n  }\n\n  public getResponsiveImageUrls(originalKey: string): Record<string, string> {\n    const urls: Record<string, string> = {};\n    \n    this.thumbnailConfigs.forEach(config => {\n      urls[config.name] = this.getThumbnailUrl(originalKey, config.name);\n    });\n    \n    urls.original = `https://${this.config.cdnDomain}/${originalKey}`;\n    \n    return urls;\n  }\n\n  private isImageFile(key: string): boolean {\n    const imageExtensions = ['.jpg', '.jpeg', '.png', '.gif', '.webp', '.avif', '.bmp', '.tiff'];\n    const extension = key.toLowerCase().substring(key.lastIndexOf('.'));\n    return imageExtensions.includes(extension);\n  }\n\n  private getContentType(key: string): string {\n    const extension = key.toLowerCase().substring(key.lastIndexOf('.'));\n    \n    const mimeTypes: Record<string, string> = {\n      '.jpg': 'image/jpeg',\n      '.jpeg': 'image/jpeg',\n      '.png': 'image/png',\n      '.gif': 'image/gif',\n      '.webp': 'image/webp',\n      '.avif': 'image/avif',\n      '.pdf': 'application/pdf',\n      '.txt': 'text/plain',\n      '.json': 'application/json',\n      '.css': 'text/css',\n      '.js': 'application/javascript',\n      '.html': 'text/html',\n      '.xml': 'application/xml',\n      '.zip': 'application/zip',\n    };\n    \n    return mimeTypes[extension] || 'application/octet-stream';\n  }\n\n  private addHashToKey(key: string, hash: string): string {\n    const lastDotIndex = key.lastIndexOf('.');\n    if (lastDotIndex === -1) {\n      return `${key}_${hash.substring(0, 8)}`;\n    }\n    \n    const name = key.substring(0, lastDotIndex);\n    const extension = key.substring(lastDotIndex);\n    return `${name}_${hash.substring(0, 8)}${extension}`;\n  }\n\n  private getThumbnailKey(originalKey: string, thumbnailType: string): string {\n    const lastDotIndex = originalKey.lastIndexOf('.');\n    if (lastDotIndex === -1) {\n      return `${originalKey}_${thumbnailType}`;\n    }\n    \n    const name = originalKey.substring(0, lastDotIndex);\n    const extension = originalKey.substring(lastDotIndex);\n    \n    // Change extension based on thumbnail type\n    let newExtension = extension;\n    if (thumbnailType.includes('webp')) {\n      newExtension = '.webp';\n    } else if (thumbnailType.includes('avif')) {\n      newExtension = '.avif';\n    }\n    \n    return `thumbnails/${name}_${thumbnailType}${newExtension}`;\n  }\n\n  public async getStorageStats(): Promise<{\n    totalSize: number;\n    fileCount: number;\n    averageFileSize: number;\n    storageByType: Record<string, { count: number; size: number }>;\n  }> {\n    try {\n      const files = await this.listFiles();\n      \n      let totalSize = 0;\n      const storageByType: Record<string, { count: number; size: number }> = {};\n      \n      files.forEach(file => {\n        totalSize += file.size;\n        \n        const extension = file.key.toLowerCase().substring(file.key.lastIndexOf('.'));\n        if (!storageByType[extension]) {\n          storageByType[extension] = { count: 0, size: 0 };\n        }\n        \n        storageByType[extension].count++;\n        storageByType[extension].size += file.size;\n      });\n      \n      return {\n        totalSize,\n        fileCount: files.length,\n        averageFileSize: files.length > 0 ? totalSize / files.length : 0,\n        storageByType,\n      };\n    } catch (error) {\n      console.error('Failed to get storage stats:', error);\n      return {\n        totalSize: 0,\n        fileCount: 0,\n        averageFileSize: 0,\n        storageByType: {},\n      };\n    }\n  }\n\n  public async cleanup(olderThanDays: number = 30): Promise<number> {\n    try {\n      const cutoffDate = new Date(Date.now() - olderThanDays * 24 * 60 * 60 * 1000);\n      const files = await this.listFiles();\n      \n      const filesToDelete = files.filter(file => file.lastModified < cutoffDate);\n      \n      let deletedCount = 0;\n      for (const file of filesToDelete) {\n        const success = await this.deleteFile(file.key);\n        if (success) {\n          deletedCount++;\n        }\n      }\n      \n      this.emit('cleanupCompleted', { deletedCount, totalFiles: files.length });\n      return deletedCount;\n    } catch (error) {\n      this.emit('cleanupError', error);\n      console.error('Failed to cleanup old files:', error);\n      return 0;\n    }\n  }\n}\n\n// Singleton instance\nlet cdnServiceInstance: CDNService;\n\nexport const initializeCDNService = (config: CDNConfig): CDNService => {\n  if (!cdnServiceInstance) {\n    cdnServiceInstance = new CDNService(config);\n  }\n  return cdnServiceInstance;\n};\n\nexport const cdnService = cdnServiceInstance;\n\nexport default CDNService;\nexport { CDNConfig, CDNAsset, UploadOptions, ImageOptimizationOptions };"