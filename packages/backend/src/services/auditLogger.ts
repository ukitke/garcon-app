import { createLogger, format, transports } from 'winston';\nimport DailyRotateFile from 'winston-daily-rotate-file';\nimport { Pool } from 'pg';\nimport { Redis } from 'ioredis';\nimport { EventEmitter } from 'events';\nimport crypto from 'crypto';\n\ninterface SecurityEvent {\n  type: string;\n  ip?: string;\n  userAgent?: string;\n  endpoint?: string;\n  method?: string;\n  userId?: string;\n  sessionId?: string;\n  timestamp: Date;\n  severity?: 'low' | 'medium' | 'high' | 'critical';\n  [key: string]: any;\n}\n\ninterface RequestLog {\n  method: string;\n  url: string;\n  ip?: string;\n  userAgent?: string;\n  statusCode: number;\n  duration: number;\n  contentLength?: string;\n  userId?: string;\n  sessionId?: string;\n  timestamp: Date;\n}\n\ninterface AuditEvent {\n  id: string;\n  type: 'security' | 'request' | 'business' | 'system';\n  category: string;\n  action: string;\n  userId?: string;\n  sessionId?: string;\n  resourceId?: string;\n  resourceType?: string;\n  ip?: string;\n  userAgent?: string;\n  data?: any;\n  result: 'success' | 'failure' | 'error';\n  timestamp: Date;\n  hash?: string;\n}\n\nclass AuditLogger extends EventEmitter {\n  private logger: any;\n  private dbPool: Pool;\n  private redis: Redis;\n  private encryptionKey: string;\n  private alertThresholds: Map<string, { count: number; window: number; severity: string }> = new Map();\n\n  constructor(dbPool: Pool, redis: Redis) {\n    super();\n    this.dbPool = dbPool;\n    this.redis = redis;\n    this.encryptionKey = process.env.AUDIT_ENCRYPTION_KEY || 'default-key-change-in-production';\n    \n    this.setupLogger();\n    this.setupAlertThresholds();\n    this.setupEventHandlers();\n  }\n\n  private setupLogger() {\n    const logFormat = format.combine(\n      format.timestamp(),\n      format.errors({ stack: true }),\n      format.json(),\n      format.printf(({ timestamp, level, message, ...meta }) => {\n        return JSON.stringify({\n          timestamp,\n          level,\n          message,\n          ...meta,\n        });\n      })\n    );\n\n    this.logger = createLogger({\n      level: 'info',\n      format: logFormat,\n      defaultMeta: { service: 'garcon-api' },\n      transports: [\n        // Console logging for development\n        new transports.Console({\n          format: format.combine(\n            format.colorize(),\n            format.simple()\n          ),\n        }),\n\n        // Security events log\n        new DailyRotateFile({\n          filename: 'logs/security-%DATE%.log',\n          datePattern: 'YYYY-MM-DD',\n          maxSize: '20m',\n          maxFiles: '30d',\n          level: 'warn',\n        }),\n\n        // General application log\n        new DailyRotateFile({\n          filename: 'logs/application-%DATE%.log',\n          datePattern: 'YYYY-MM-DD',\n          maxSize: '20m',\n          maxFiles: '14d',\n        }),\n\n        // Error log\n        new DailyRotateFile({\n          filename: 'logs/error-%DATE%.log',\n          datePattern: 'YYYY-MM-DD',\n          maxSize: '20m',\n          maxFiles: '30d',\n          level: 'error',\n        }),\n\n        // Audit log (encrypted)\n        new DailyRotateFile({\n          filename: 'logs/audit-%DATE%.log',\n          datePattern: 'YYYY-MM-DD',\n          maxSize: '50m',\n          maxFiles: '90d',\n          format: format.combine(\n            format.timestamp(),\n            format.printf((info) => {\n              return this.encryptLogEntry(JSON.stringify(info));\n            })\n          ),\n        }),\n      ],\n    });\n  }\n\n  private setupAlertThresholds() {\n    // Define thresholds for different security events\n    this.alertThresholds.set('FAILED_LOGIN', { count: 5, window: 300, severity: 'medium' }); // 5 in 5 minutes\n    this.alertThresholds.set('RATE_LIMIT_EXCEEDED', { count: 10, window: 600, severity: 'medium' }); // 10 in 10 minutes\n    this.alertThresholds.set('SQL_INJECTION_ATTEMPT', { count: 1, window: 60, severity: 'high' }); // 1 in 1 minute\n    this.alertThresholds.set('SUSPICIOUS_ACTIVITY_DETECTED', { count: 3, window: 300, severity: 'high' }); // 3 in 5 minutes\n    this.alertThresholds.set('BLACKLISTED_IP_ACCESS', { count: 1, window: 60, severity: 'critical' }); // 1 in 1 minute\n    this.alertThresholds.set('PAYMENT_FRAUD_DETECTED', { count: 1, window: 60, severity: 'critical' }); // 1 in 1 minute\n  }\n\n  private setupEventHandlers() {\n    this.on('securityAlert', this.handleSecurityAlert.bind(this));\n    this.on('auditEvent', this.storeAuditEvent.bind(this));\n  }\n\n  private encryptLogEntry(data: string): string {\n    try {\n      const cipher = crypto.createCipher('aes-256-cbc', this.encryptionKey);\n      let encrypted = cipher.update(data, 'utf8', 'hex');\n      encrypted += cipher.final('hex');\n      return encrypted;\n    } catch (error) {\n      console.error('Failed to encrypt log entry:', error);\n      return data; // Fallback to unencrypted in case of error\n    }\n  }\n\n  private decryptLogEntry(encryptedData: string): string {\n    try {\n      const decipher = crypto.createDecipher('aes-256-cbc', this.encryptionKey);\n      let decrypted = decipher.update(encryptedData, 'hex', 'utf8');\n      decrypted += decipher.final('utf8');\n      return decrypted;\n    } catch (error) {\n      console.error('Failed to decrypt log entry:', error);\n      return encryptedData;\n    }\n  }\n\n  private generateEventHash(event: AuditEvent): string {\n    const hashData = `${event.type}:${event.category}:${event.action}:${event.timestamp.toISOString()}:${event.userId || 'anonymous'}`;\n    return crypto.createHash('sha256').update(hashData).digest('hex');\n  }\n\n  public async logSecurityEvent(event: SecurityEvent): Promise<void> {\n    try {\n      const severity = event.severity || this.determineSeverity(event.type);\n      const logEntry = {\n        ...event,\n        severity,\n        eventId: crypto.randomUUID(),\n      };\n\n      // Log to Winston\n      this.logger.warn('Security Event', logEntry);\n\n      // Store in database\n      await this.storeSecurityEvent(logEntry);\n\n      // Check for alert thresholds\n      await this.checkAlertThresholds(event.type, event.ip);\n\n      // Emit audit event\n      this.emit('auditEvent', {\n        id: crypto.randomUUID(),\n        type: 'security',\n        category: 'security_event',\n        action: event.type,\n        userId: event.userId,\n        sessionId: event.sessionId,\n        ip: event.ip,\n        userAgent: event.userAgent,\n        data: event,\n        result: 'success',\n        timestamp: new Date(),\n      });\n\n    } catch (error) {\n      console.error('Failed to log security event:', error);\n      this.logger.error('Audit logging failed', { error: error.message, event });\n    }\n  }\n\n  public async logRequest(request: RequestLog): Promise<void> {\n    try {\n      // Log to Winston (info level for successful requests, warn for errors)\n      const logLevel = request.statusCode >= 400 ? 'warn' : 'info';\n      this.logger.log(logLevel, 'HTTP Request', request);\n\n      // Store in database for analytics\n      await this.storeRequestLog(request);\n\n      // Emit audit event for significant requests\n      if (request.statusCode >= 400 || request.duration > 5000) {\n        this.emit('auditEvent', {\n          id: crypto.randomUUID(),\n          type: 'request',\n          category: 'http_request',\n          action: `${request.method} ${request.url}`,\n          userId: request.userId,\n          sessionId: request.sessionId,\n          ip: request.ip,\n          userAgent: request.userAgent,\n          data: request,\n          result: request.statusCode < 400 ? 'success' : 'error',\n          timestamp: new Date(),\n        });\n      }\n\n    } catch (error) {\n      console.error('Failed to log request:', error);\n    }\n  }\n\n  public async logBusinessEvent(event: {\n    action: string;\n    userId?: string;\n    sessionId?: string;\n    resourceId?: string;\n    resourceType?: string;\n    data?: any;\n    result: 'success' | 'failure' | 'error';\n  }): Promise<void> {\n    try {\n      const auditEvent: AuditEvent = {\n        id: crypto.randomUUID(),\n        type: 'business',\n        category: 'business_operation',\n        action: event.action,\n        userId: event.userId,\n        sessionId: event.sessionId,\n        resourceId: event.resourceId,\n        resourceType: event.resourceType,\n        data: event.data,\n        result: event.result,\n        timestamp: new Date(),\n      };\n\n      auditEvent.hash = this.generateEventHash(auditEvent);\n\n      this.logger.info('Business Event', auditEvent);\n      this.emit('auditEvent', auditEvent);\n\n    } catch (error) {\n      console.error('Failed to log business event:', error);\n    }\n  }\n\n  private async storeSecurityEvent(event: SecurityEvent & { eventId: string; severity: string }): Promise<void> {\n    try {\n      const query = `\n        INSERT INTO security_events (\n          id, type, severity, ip, user_agent, endpoint, method, \n          user_id, session_id, data, created_at\n        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)\n      `;\n\n      await this.dbPool.query(query, [\n        event.eventId,\n        event.type,\n        event.severity,\n        event.ip,\n        event.userAgent,\n        event.endpoint,\n        event.method,\n        event.userId,\n        event.sessionId,\n        JSON.stringify(event),\n        event.timestamp,\n      ]);\n\n    } catch (error) {\n      console.error('Failed to store security event in database:', error);\n    }\n  }\n\n  private async storeRequestLog(request: RequestLog): Promise<void> {\n    try {\n      const query = `\n        INSERT INTO request_logs (\n          method, url, ip, user_agent, status_code, duration, \n          content_length, user_id, session_id, created_at\n        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10)\n      `;\n\n      await this.dbPool.query(query, [\n        request.method,\n        request.url,\n        request.ip,\n        request.userAgent,\n        request.statusCode,\n        request.duration,\n        request.contentLength ? parseInt(request.contentLength, 10) : null,\n        request.userId,\n        request.sessionId,\n        request.timestamp,\n      ]);\n\n    } catch (error) {\n      console.error('Failed to store request log in database:', error);\n    }\n  }\n\n  private async storeAuditEvent(event: AuditEvent): Promise<void> {\n    try {\n      const query = `\n        INSERT INTO audit_events (\n          id, type, category, action, user_id, session_id, resource_id, \n          resource_type, ip, user_agent, data, result, hash, created_at\n        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14)\n      `;\n\n      await this.dbPool.query(query, [\n        event.id,\n        event.type,\n        event.category,\n        event.action,\n        event.userId,\n        event.sessionId,\n        event.resourceId,\n        event.resourceType,\n        event.ip,\n        event.userAgent,\n        JSON.stringify(event.data),\n        event.result,\n        event.hash,\n        event.timestamp,\n      ]);\n\n    } catch (error) {\n      console.error('Failed to store audit event in database:', error);\n    }\n  }\n\n  private async checkAlertThresholds(eventType: string, ip?: string): Promise<void> {\n    const threshold = this.alertThresholds.get(eventType);\n    if (!threshold || !ip) return;\n\n    try {\n      const key = `security_alert:${eventType}:${ip}`;\n      const count = await this.redis.incr(key);\n      \n      if (count === 1) {\n        await this.redis.expire(key, threshold.window);\n      }\n\n      if (count >= threshold.count) {\n        this.emit('securityAlert', {\n          type: eventType,\n          ip,\n          count,\n          threshold: threshold.count,\n          window: threshold.window,\n          severity: threshold.severity,\n          timestamp: new Date(),\n        });\n\n        // Reset counter after alert\n        await this.redis.del(key);\n      }\n\n    } catch (error) {\n      console.error('Failed to check alert thresholds:', error);\n    }\n  }\n\n  private async handleSecurityAlert(alert: any): Promise<void> {\n    try {\n      this.logger.error('Security Alert Triggered', alert);\n\n      // Store alert in database\n      const query = `\n        INSERT INTO security_alerts (\n          id, type, ip, count, threshold_count, time_window, \n          severity, data, created_at\n        ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9)\n      `;\n\n      await this.dbPool.query(query, [\n        crypto.randomUUID(),\n        alert.type,\n        alert.ip,\n        alert.count,\n        alert.threshold,\n        alert.window,\n        alert.severity,\n        JSON.stringify(alert),\n        alert.timestamp,\n      ]);\n\n      // Send notifications based on severity\n      if (alert.severity === 'critical' || alert.severity === 'high') {\n        await this.sendSecurityNotification(alert);\n      }\n\n      // Auto-block IP for critical alerts\n      if (alert.severity === 'critical') {\n        await this.autoBlockIP(alert.ip, alert.type);\n      }\n\n    } catch (error) {\n      console.error('Failed to handle security alert:', error);\n    }\n  }\n\n  private async sendSecurityNotification(alert: any): Promise<void> {\n    // This would integrate with your notification system (email, Slack, etc.)\n    console.log('SECURITY ALERT:', alert);\n    \n    // Example: Send to monitoring service\n    // await monitoringService.sendAlert(alert);\n  }\n\n  private async autoBlockIP(ip: string, reason: string): Promise<void> {\n    try {\n      // Add IP to temporary blacklist\n      const blockKey = `blocked_ip:${ip}`;\n      await this.redis.setex(blockKey, 3600, reason); // Block for 1 hour\n\n      this.logger.warn('IP Auto-blocked', { ip, reason, duration: '1 hour' });\n\n      // Store in database for permanent record\n      const query = `\n        INSERT INTO blocked_ips (ip, reason, blocked_at, expires_at, auto_blocked)\n        VALUES ($1, $2, $3, $4, $5)\n      `;\n\n      const expiresAt = new Date(Date.now() + 3600 * 1000); // 1 hour from now\n      await this.dbPool.query(query, [ip, reason, new Date(), expiresAt, true]);\n\n    } catch (error) {\n      console.error('Failed to auto-block IP:', error);\n    }\n  }\n\n  private determineSeverity(eventType: string): string {\n    const highSeverityEvents = [\n      'SQL_INJECTION_ATTEMPT',\n      'XSS_ATTEMPT',\n      'SUSPICIOUS_ACTIVITY_DETECTED',\n      'PAYMENT_FRAUD_DETECTED',\n    ];\n\n    const criticalSeverityEvents = [\n      'BLACKLISTED_IP_ACCESS',\n      'ADMIN_ACCOUNT_COMPROMISE',\n      'DATA_BREACH_DETECTED',\n    ];\n\n    if (criticalSeverityEvents.includes(eventType)) {\n      return 'critical';\n    }\n\n    if (highSeverityEvents.includes(eventType)) {\n      return 'high';\n    }\n\n    return 'medium';\n  }\n\n  public async getSecurityEvents(filters: {\n    startDate?: Date;\n    endDate?: Date;\n    type?: string;\n    severity?: string;\n    ip?: string;\n    limit?: number;\n    offset?: number;\n  }): Promise<any[]> {\n    try {\n      let query = 'SELECT * FROM security_events WHERE 1=1';\n      const params: any[] = [];\n      let paramIndex = 1;\n\n      if (filters.startDate) {\n        query += ` AND created_at >= $${paramIndex}`;\n        params.push(filters.startDate);\n        paramIndex++;\n      }\n\n      if (filters.endDate) {\n        query += ` AND created_at <= $${paramIndex}`;\n        params.push(filters.endDate);\n        paramIndex++;\n      }\n\n      if (filters.type) {\n        query += ` AND type = $${paramIndex}`;\n        params.push(filters.type);\n        paramIndex++;\n      }\n\n      if (filters.severity) {\n        query += ` AND severity = $${paramIndex}`;\n        params.push(filters.severity);\n        paramIndex++;\n      }\n\n      if (filters.ip) {\n        query += ` AND ip = $${paramIndex}`;\n        params.push(filters.ip);\n        paramIndex++;\n      }\n\n      query += ' ORDER BY created_at DESC';\n\n      if (filters.limit) {\n        query += ` LIMIT $${paramIndex}`;\n        params.push(filters.limit);\n        paramIndex++;\n      }\n\n      if (filters.offset) {\n        query += ` OFFSET $${paramIndex}`;\n        params.push(filters.offset);\n      }\n\n      const result = await this.dbPool.query(query, params);\n      return result.rows;\n\n    } catch (error) {\n      console.error('Failed to get security events:', error);\n      return [];\n    }\n  }\n\n  public async getAuditTrail(filters: {\n    userId?: string;\n    resourceId?: string;\n    action?: string;\n    startDate?: Date;\n    endDate?: Date;\n    limit?: number;\n    offset?: number;\n  }): Promise<any[]> {\n    try {\n      let query = 'SELECT * FROM audit_events WHERE 1=1';\n      const params: any[] = [];\n      let paramIndex = 1;\n\n      if (filters.userId) {\n        query += ` AND user_id = $${paramIndex}`;\n        params.push(filters.userId);\n        paramIndex++;\n      }\n\n      if (filters.resourceId) {\n        query += ` AND resource_id = $${paramIndex}`;\n        params.push(filters.resourceId);\n        paramIndex++;\n      }\n\n      if (filters.action) {\n        query += ` AND action = $${paramIndex}`;\n        params.push(filters.action);\n        paramIndex++;\n      }\n\n      if (filters.startDate) {\n        query += ` AND created_at >= $${paramIndex}`;\n        params.push(filters.startDate);\n        paramIndex++;\n      }\n\n      if (filters.endDate) {\n        query += ` AND created_at <= $${paramIndex}`;\n        params.push(filters.endDate);\n        paramIndex++;\n      }\n\n      query += ' ORDER BY created_at DESC';\n\n      if (filters.limit) {\n        query += ` LIMIT $${paramIndex}`;\n        params.push(filters.limit);\n        paramIndex++;\n      }\n\n      if (filters.offset) {\n        query += ` OFFSET $${paramIndex}`;\n        params.push(filters.offset);\n      }\n\n      const result = await this.dbPool.query(query, params);\n      return result.rows;\n\n    } catch (error) {\n      console.error('Failed to get audit trail:', error);\n      return [];\n    }\n  }\n}\n\n// Singleton instance\nlet auditLoggerInstance: AuditLogger;\n\nexport const initializeAuditLogger = (dbPool: Pool, redis: Redis): AuditLogger => {\n  if (!auditLoggerInstance) {\n    auditLoggerInstance = new AuditLogger(dbPool, redis);\n  }\n  return auditLoggerInstance;\n};\n\nexport const auditLogger = auditLoggerInstance;\n\nexport default AuditLogger;"